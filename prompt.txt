Car Brands Management CRUD Project — Complete Summary
Phase 0 — Setup & Planning

Goal: Build a Student/Car Management CRUD app.

Stack:

Frontend: React (VS Code, Node 18)

Backend: Spring Boot (IntelliJ, Java 17, Maven)

Database: H2 (In-memory)

DevOps: GitHub, GitHub Actions, Docker, optional Vercel

Constraints:

Each file ≤ 100 lines

Each function ≤ 17 lines

Phase 1 — Backend Initialization

Use Spring Initializr, Maven, Java 17.

Dependencies:

spring-web

spring-data-jpa

h2

spring-devtools

Run Spring Boot app → should start at port 8080.

Phase 2 — Backend Structure & CRUD

Packages:
com.example.crud → model, repository, service, controller

Responsibilities:

Model → Entity (Student or Car)

Repository → JPA database access

Service → Business logic

Controller → REST endpoints

CRUD Endpoints:

GET /api/students → Read

POST /api/students → Create

PUT /api/students/{id} → Update

DELETE /api/students/{id} → Delete

Phase 3 — Database Configuration

Use H2 in-memory database:

spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.h2.console.enabled=true
spring.h2.console.settings.web-allow-others=true


Verify table creation via H2 console.

Phase 4 — Frontend Setup

React app → npx create-react-app frontend

Folder structure:
src/components → UI components
src/services → API calls

App runs on port 3000.

Phase 5 — Frontend CRUD Integration

API service (axios or fetch) to call Spring Boot endpoints.

Implement forms for Create/Update, lists for Read, buttons for Delete.

Verify full frontend functionality.

Phase 6 — Version Control

Initialize Git repo for frontend and backend.

Add .gitignore.

Push everything to GitHub.

Phase 7 — CI/CD (GitHub Actions)

Actions:

Build Spring Boot on push

Run backend tests

Optional: Lint React app, run frontend tests

Outcome: CI passes automatically on each commit.

Phase 8 — Dockerization

Backend Dockerfile example:

FROM openjdk:17-jdk
WORKDIR /app
COPY target/carcrud-0.0.1-SNAPSHOT.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java","-jar","app.jar"]


Frontend Dockerfile example:

FROM node:18
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build
EXPOSE 3000
CMD ["npx","serve","-s","build","-l","3000"]


Build images → docker build -t carcrud-backend .

Run containers → verify communication.

Phase 9 — Local Deployment

Start containers:

docker run -p 8080:8080 carcrud-backend
docker run -p 3000:3000 carcrud-frontend


Access in browser → check CRUD.

Phase 10 — SonarCloud Analysis

Sign up / log in at SonarCloud
 → GitHub login.

Project key example: carcrud-backend

Organization: GitHub username OR org ID (myusername-github)

Add to application.properties (or separate sonar-project.properties):

sonar.projectKey=carcrud-backend
sonar.organization=myusername-github
sonar.host.url=https://sonarcloud.io
sonar.login=<YOUR_SONAR_TOKEN>


Run scan via Maven:

mvn sonar:sonar


Frontend scan: optional, can use sonar-project.properties in React folder with JavaScript/TypeScript setup.

Tip: This gives code quality, bugs, coverage, and duplications.

Phase 11 — Deployment Options

Vercel: Quick deploy for React frontend:

Connect GitHub repo → Deploy frontend only.

Use backend URL from local Docker or deployed server.

GitHub Pages: Only static → can’t run backend; React must be built as static.

Phase 12 — Final Validation

Test all CRUD operations end-to-end.

Check Docker containers communicate.

Validate line constraints (≤100 lines/file, ≤17 lines/function).

Add README → setup instructions, endpoints, Docker commands.

Optionally include SonarCloud badges in README.

✅ Project Complete:

Frontend + Backend fully functional

Dockerized and locally deployable

CI/CD running

SonarCloud analysis ready

Optional Vercel deployment for React

ask me if you need any codes